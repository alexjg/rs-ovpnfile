extern crate ovpnfile;
extern crate spectral;

use spectral::boolean::BooleanAssertions;
use std::io::{BufReader};
use ovpnfile::{ConfigDirective, ServerGatewayArg};

#[test]
fn test_reads_ovpnfile() {
    let expected_result: Vec<ConfigDirective> = vec![
        ConfigDirective::Help,
        ConfigDirective::Config{file: "some_file".to_string()},
        ConfigDirective::Mode{m: "some_mode".to_string()},
        ConfigDirective::Local{host: "somehost".to_string()},
        ConfigDirective::Remote{host: "somehost".to_string(), port: None, proto: None},
        ConfigDirective::Remote{host: "somehost".to_string(), port: Some("someport".to_string()), proto: None},
        ConfigDirective::Remote{host: "host".to_string(), port: Some("someport".to_string()), proto: Some("someproto".to_string())},
        ConfigDirective::RemoteRandomHostname,
        ConfigDirective::ProtoForce{p: "someproto".to_string()},
        ConfigDirective::RemoteRandom,
        ConfigDirective::Proto{p: "someproto".to_string()},
        ConfigDirective::ConnectRetry{n: "10".to_string(), max: None},
        ConfigDirective::ConnectRetry{n: "10".to_string(), max: Some("5".to_string())},
        ConfigDirective::ConnectRetryMax{n: "10".to_string()},
        ConfigDirective::ShowProxySettings,
        ConfigDirective::HttpProxy{server: "server".to_string(), port: "port".to_string(), authfile_or_auto_or_auto_nct: None, auth_method: None},
        ConfigDirective::HttpProxy{server: "server".to_string(), port: "port".to_string(), authfile_or_auto_or_auto_nct: Some("authfile".to_string()), auth_method: None},
        ConfigDirective::HttpProxy{server: "server".to_string(), port: "port".to_string(), authfile_or_auto_or_auto_nct: Some("authfile".to_string()), auth_method: Some("someathmethod".to_string())},
        ConfigDirective::HttpProxyOption{http_proxy_option_type: "sometype".to_string(), parm: None},
        ConfigDirective::HttpProxyOption{http_proxy_option_type: "sometype".to_string(), parm: Some("someparm".to_string())},
        ConfigDirective::SocksProxy{server: "someserver".to_string(), port: None, authfile: None},
        ConfigDirective::SocksProxy{server: "someserver".to_string(), port: Some("someport".to_string()), authfile: None},
        ConfigDirective::SocksProxy{server: "someserver".to_string(), port: Some("someport".to_string()), authfile: Some("someauthfile".to_string())},
        ConfigDirective::ResolvRetry{n: "10".to_string()},
        ConfigDirective::Float,
        ConfigDirective::Ipchange{cmd: "somecmd".to_string()},
        ConfigDirective::Port{port: "someport".to_string()},
        ConfigDirective::Lport{port: "somelport".to_string()},
        ConfigDirective::Rport{port: "somerport".to_string()},
        ConfigDirective::Bind{ipv6only: None},
        ConfigDirective::Bind{ipv6only: Some("ipv6only".to_string())},
        ConfigDirective::Nobind,
        ConfigDirective::Dev{devarg: "tunX".to_string()},
        ConfigDirective::DevType{device_type: "somedevicetype".to_string()},
        ConfigDirective::Topology{mode: "somemode".to_string()},
        ConfigDirective::DevNode{node: "somenode".to_string()},
        ConfigDirective::Lladdr{address: "someaddress".to_string()},
        ConfigDirective::Iproute{cmd: "somecmd".to_string()},
        ConfigDirective::Ifconfig{l: "somel".to_string(), rn: "somern".to_string()},
        ConfigDirective::IfconfigNoexec,
        ConfigDirective::IfconfigNowarn,
        ConfigDirective::Route{network_or_ip: "network_or_ip".to_string(), netmask: None, gateway: None, metric: None},
        ConfigDirective::Route{network_or_ip: "network_or_ip".to_string(), netmask: Some("somenetmask".to_string()), gateway: None, metric: None},
        ConfigDirective::Route{network_or_ip: "network_or_ip".to_string(), netmask: Some("somenetmask".to_string()), gateway: Some("somegateway".to_string()), metric: None},
        ConfigDirective::Route{network_or_ip: "network_or_ip".to_string(), netmask: Some("somenetmask".to_string()), gateway: Some("somegateway".to_string()), metric: Some("somemetric".to_string())},
        ConfigDirective::RouteGateway{gw_or_dhcp: "gateway".to_string()},
        ConfigDirective::RouteMetric{m: "10".to_string()},
        ConfigDirective::RouteDelay{n: None, w: None},
        ConfigDirective::RouteDelay{n: Some("10".to_string()), w: None},
        ConfigDirective::RouteDelay{n: Some("10".to_string()), w: Some("5".to_string())},
        ConfigDirective::RouteUp{cmd: "somecmd".to_string()},
        ConfigDirective::RoutePreDown{cmd: "somecmd".to_string()},
        ConfigDirective::RouteNoexec,
        ConfigDirective::RouteNopull,
        ConfigDirective::AllowPullFqdn,
        ConfigDirective::ClientNat{snat_or_dnat: "snat".to_string(), network: "somenetwork".to_string(), netmask: "somenetmask".to_string(), alias: "somealias".to_string()},
        ConfigDirective::RedirectGateway{flags: vec!["flag1".to_string(), "flag2".to_string()]},
        ConfigDirective::LinkMtu{n: "10".to_string()},
        ConfigDirective::RedirectPrivate{flags: None},
        ConfigDirective::RedirectPrivate{flags: Some(vec!["flag1".to_string(), "flag2".to_string()])},
        ConfigDirective::TunMtu{n: "10".to_string()},
        ConfigDirective::TunMtuExtra{n: "10".to_string()},
        ConfigDirective::MtuDisc{mtu_disc_type: "sometype".to_string()},
        ConfigDirective::MtuTest,
        ConfigDirective::Fragment{max: "10".to_string()},
        ConfigDirective::Mssfix{max: "10".to_string()},
        ConfigDirective::Sndbuf{size: "10".to_string()},
        ConfigDirective::Rcvbuf{size: "10".to_string()},
        ConfigDirective::Mark{value: "somevalue".to_string()},
        ConfigDirective::SocketFlags{flags: vec!["flag1".to_string(), "flag2".to_string()]},
        ConfigDirective::Txqueuelen{n: "10".to_string()},
        ConfigDirective::Shaper{n: "10".to_string()},
        ConfigDirective::Inactive{n: "10".to_string(), bytes: None},
        ConfigDirective::Inactive{n: "10".to_string(), bytes: Some("20".to_string())},
        ConfigDirective::Ping{n: "10".to_string()},
        ConfigDirective::PingExit{n: "10".to_string()},
        ConfigDirective::PingRestart{n: "10".to_string()},
        ConfigDirective::Keepalive{interval: "someinterval".to_string(), timeout: "sometimeout".to_string()},
        ConfigDirective::PingTimerRem,
        ConfigDirective::PersistTun,
        ConfigDirective::PersistKey,
        ConfigDirective::PersistLocalIp,
        ConfigDirective::PersistRemoteIp,
        ConfigDirective::Mlock,
        ConfigDirective::Up{cmd: "cmd".to_string()},
        ConfigDirective::UpDelay,
        ConfigDirective::Down{cmd: "cmd".to_string()},
        ConfigDirective::DownPre,
        ConfigDirective::UpRestart,
        ConfigDirective::Setenv{name: "somename".to_string(), value: "somevalue".to_string()},
        ConfigDirective::SetenvSafe{name: "somename".to_string(), value: "somevalue".to_string()},
        ConfigDirective::IgnoreUnknownOption{opts: vec!["opt1".to_string(), "opt2".to_string(), "opt3".to_string()]},
        ConfigDirective::ScriptSecurity{level: "somelevel".to_string()},
        ConfigDirective::DisableOcc,
        ConfigDirective::User{user: "someuser".to_string()},
        ConfigDirective::Group{group: "somegroup".to_string()},
        ConfigDirective::Cd{dir: "somedir".to_string()},
        ConfigDirective::Chroot{dir: "somedir".to_string()},
        ConfigDirective::Setcon{context: "somecontext".to_string()},
        ConfigDirective::Daemon{progname: None},
        ConfigDirective::Daemon{progname: Some("someprog".to_string())},
        ConfigDirective::Syslog{progname: None},
        ConfigDirective::Syslog{progname: Some("someprog".to_string())},
        ConfigDirective::ErrorsToStderr,
        ConfigDirective::Passtos,
        ConfigDirective::Inetd{wait_or_nowait: None, progname: None},
        ConfigDirective::Inetd{wait_or_nowait: Some("wait".to_string()), progname: None},
        ConfigDirective::Inetd{wait_or_nowait: Some("wait".to_string()), progname: Some("someprog".to_string())},
        ConfigDirective::Log{file: "somefile".to_string()},
        ConfigDirective::LogAppend{file: "somefile".to_string()},
        ConfigDirective::SuppressTimestamps,
        ConfigDirective::MachineReadableOutput,
        ConfigDirective::Writepid{file: "file".to_string()},
        ConfigDirective::Nice{n: "10".to_string()},
        ConfigDirective::FastIo,
        ConfigDirective::Multihome,
        ConfigDirective::Echo{parms: Some(vec!["parm1".to_string(), "parm2".to_string()])},
        ConfigDirective::RemapUsr1{signal: "somesignal".to_string()},
        ConfigDirective::Verb{n: "10".to_string()},
        ConfigDirective::Status{file: "somefile".to_string(), n: None},
        ConfigDirective::Status{file: "somefile".to_string(), n: Some("10".to_string())},
        ConfigDirective::StatusVersion{n: None},
        ConfigDirective::StatusVersion{n: Some("1".to_string())},
        ConfigDirective::Mute{n: "10".to_string()},
        ConfigDirective::Compress{algorithm: None},
        ConfigDirective::Compress{algorithm: Some("somealgo".to_string())},
        ConfigDirective::CompLzo{mode: None},
        ConfigDirective::CompLzo{mode: Some("no".to_string())},
        ConfigDirective::CompNoadapt,
        ConfigDirective::Management{ip: "someip".to_string(), port: "someport".to_string(), pw_file: None},
        ConfigDirective::Management{ip: "someip".to_string(), port: "someport".to_string(), pw_file: Some("somefile".to_string())},
        ConfigDirective::ManagementClient,
        ConfigDirective::ManagementQueryPasswords,
        ConfigDirective::ManagementQueryProxy,
        ConfigDirective::ManagementQueryRemote,
        ConfigDirective::ManagementExternalKey,
        ConfigDirective::ManagementExternalCert{certificate_hint: "certificate-hint".to_string()},
        ConfigDirective::ManagementForgetDisconnect,
        ConfigDirective::ManagementHold,
        ConfigDirective::ManagementSignal,
        ConfigDirective::ManagementLogCache{n: "10".to_string()},
        ConfigDirective::ManagementUpDown,
        ConfigDirective::ManagementClientAuth,
        ConfigDirective::ManagementClientPf,
        ConfigDirective::ManagementClientUser{u: "someuser".to_string()},
        ConfigDirective::ManagementClientGroup{g: "somegroup".to_string()},
        ConfigDirective::Plugin{module_pathname: "somepathname".to_string(), init_string: None},
        ConfigDirective::Plugin{module_pathname: "somepathname".to_string(), init_string: Some("someinitstring".to_string())},
        ConfigDirective::KeyingMaterialExporter{label: "somelabel".to_string(), len: "somelen".to_string()},
        ConfigDirective::Server{network: "somenetwork".to_string(), netmask: "somenetmask".to_string(), nopool: None},
        ConfigDirective::Server{network: "somenetwork".to_string(), netmask: "somenetmask".to_string(), nopool: Some("nopool".to_string())},
        ConfigDirective::Push{option: "option".to_string()},
        ConfigDirective::PushReset,
        ConfigDirective::PushRemove{opt: "someopt".to_string()},
        ConfigDirective::PushPeerInfo,
        ConfigDirective::Disable,
        ConfigDirective::IfconfigPool{start_ip: "start_ip".to_string(), end_ip: "end_ip".to_string(), netmask: None},
        ConfigDirective::IfconfigPool{start_ip: "start_ip".to_string(), end_ip: "end_ip".to_string(), netmask: Some("somenetmask".to_string())},
        ConfigDirective::IfconfigPoolPersist{file: "somefile".to_string(), seconds: None},
        ConfigDirective::IfconfigPoolPersist{file: "somefile".to_string(), seconds: Some("10".to_string())},
        ConfigDirective::IfconfigPoolLinear,
        ConfigDirective::IfconfigPush{local: "somelocal".to_string(), remote_netmask: "some_remote_netmask".to_string(), alias: None},
        ConfigDirective::IfconfigPush{local: "somelocal".to_string(), remote_netmask: "some_remote_netmask".to_string(), alias: Some("somealias".to_string())},
        ConfigDirective::Iroute{network: "somenetwork".to_string(), netmask: None},
        ConfigDirective::Iroute{network: "somenetwork".to_string(), netmask: Some("somenetmask".to_string())},
        ConfigDirective::ClientToClient,
        ConfigDirective::DuplicateCn,
        ConfigDirective::ClientConnect{cmd: "somecmd".to_string()},
        ConfigDirective::ClientDisconnect{cmd: "somecmd".to_string()},
        ConfigDirective::ClientConfigDir{dir: "somedir".to_string()},
        ConfigDirective::CcdExclusive,
        ConfigDirective::TmpDir{dir: "somedir".to_string()},
        ConfigDirective::HashSize{r: "somer".to_string(), v: "somev".to_string()},
        ConfigDirective::BcastBuffers{n: "10".to_string()},
        ConfigDirective::TcpQueueLimit{n: "10".to_string()},
        ConfigDirective::TcpNodelay,
        ConfigDirective::MaxClients{n: "10".to_string()},
        ConfigDirective::MaxRoutesPerClient{n: "10".to_string()},
        ConfigDirective::StaleRoutesCheck{n: "10".to_string(), t: None},
        ConfigDirective::StaleRoutesCheck{n: "10".to_string(), t: Some("15".to_string())},
        ConfigDirective::ConnectFreq{n: "10".to_string(), sec: "15".to_string()},
        ConfigDirective::LearnAddress{cmd: "somecmd".to_string()},
        ConfigDirective::AuthUserPassVerify{cmd: "somecmd".to_string(), method: "somemethod".to_string()},
        ConfigDirective::AuthGenToken{lifetime: None},
        ConfigDirective::AuthGenToken{lifetime: Some("somelifetime".to_string())},
        ConfigDirective::OptVerify,
        ConfigDirective::AuthUserPassOptional,
        ConfigDirective::ClientCertNotRequired,
        ConfigDirective::VerifyClientCert{none_optional_require: "none".to_string()},
        ConfigDirective::UsernameAsCommonName,
        ConfigDirective::CompatNames{no_remapping: None},
        ConfigDirective::CompatNames{no_remapping: Some("somenoremapping".to_string())},
        ConfigDirective::NoNameRemapping,
        ConfigDirective::PortShare{host: "somehost".to_string(), port: "someport".to_string(), dir: None},
        ConfigDirective::PortShare{host: "somehost".to_string(), port: "someport".to_string(), dir: Some("somedir".to_string())},
        ConfigDirective::Client,
        ConfigDirective::Pull,
        ConfigDirective::PullFilter{accept_or_ignore_or_reject: "accept".to_string(), text: "sometext".to_string()},
        ConfigDirective::AuthUserPass{up: None},
        ConfigDirective::AuthUserPass{up: Some("somefile".to_string())},
        ConfigDirective::AuthRetry{auth_retry_type: "sometype".to_string()},
        ConfigDirective::StaticChallenge{t: "sometext".to_string(), e: "someflag".to_string()},
        ConfigDirective::ServerPollTimeout{n: "10".to_string()},
        ConfigDirective::ConnectTimeout{n: "10".to_string()},
        ConfigDirective::ExplicitExitNotify{n: None},
        ConfigDirective::ExplicitExitNotify{n: Some("10".to_string())},
        ConfigDirective::AllowRecursiveRouting,
        ConfigDirective::Secret{file: "somefile".to_string(), direction: None},
        ConfigDirective::Secret{file: "somefile".to_string(), direction: Some("somedirection".to_string())},
        ConfigDirective::KeyDirection{direction: "somedirection".to_string()},
        ConfigDirective::Auth{alg: "somealg".to_string()},
        ConfigDirective::Cipher{alg: "somealg".to_string()},
        ConfigDirective::NcpCiphers{cipher_list: "cipher1:cipher2".to_string()},
        ConfigDirective::NcpDisable,
        ConfigDirective::Keysize{n: "10".to_string()},
        ConfigDirective::Prng{alg: "somealg".to_string(), nsl: None},
        ConfigDirective::Prng{alg: "somealg".to_string(), nsl: Some("16".to_string())},
        ConfigDirective::Engine{engine_name: None},
        ConfigDirective::Engine{engine_name: Some("someengine".to_string())},
        ConfigDirective::NoReplay,
        ConfigDirective::ReplayWindow{n: "10".to_string(), t: None},
        ConfigDirective::ReplayWindow{n: "10".to_string(), t: Some("15".to_string())},
        ConfigDirective::MuteReplayWarnings,
        ConfigDirective::ReplayPersist{file: "somefile".to_string()},
        ConfigDirective::NoIv,
        ConfigDirective::UsePredictionResistance,
        ConfigDirective::TestCrypto,
        ConfigDirective::TlsServer,
        ConfigDirective::TlsClient,
        ConfigDirective::Ca{file: "somefile".to_string()},
        ConfigDirective::Capath{dir: "dir".to_string()},
        ConfigDirective::Dh{file: "somefile".to_string()},
        ConfigDirective::EcdhCurve{name: "somename".to_string()},
        ConfigDirective::Cert{file: "somefile".to_string()},
        ConfigDirective::ExtraCerts{file: "somefile".to_string()},
        ConfigDirective::Key{file: "seomfile".to_string()},
        ConfigDirective::TlsVersionMin{version: "someversion".to_string(), or_highest: None},
        ConfigDirective::TlsVersionMin{version: "someversion".to_string(), or_highest: Some("or-highest".to_string())},
        ConfigDirective::TlsVersionMax{version: "someversion".to_string()},
        ConfigDirective::Pkcs12{file: "somefile".to_string()},
        ConfigDirective::VerifyHash{hash: "somehash".to_string()},
        ConfigDirective::Pkcs11CertPrivate{providers: vec!["arg1".to_string(), "arg2".to_string()]},
        ConfigDirective::Pkcs11Id{name: "somename".to_string()},
        ConfigDirective::Pkcs11IdManagement,
        ConfigDirective::Pkcs11PinCache{seconds: "10".to_string()},
        ConfigDirective::Pkcs11ProtectedAuthentication{providers: vec!["arg1".to_string(), "arg2".to_string()]},
        ConfigDirective::Pkcs11Providers{providers: vec!["provider1".to_string(), "provider2".to_string()]},
        ConfigDirective::Pkcs11PrivateMode{modes: vec!["somemode...".to_string()]},
        ConfigDirective::Cryptoapicert{select_string: "some_select_string".to_string()},
        ConfigDirective::KeyMethod{m: "somemethod".to_string()},
        ConfigDirective::TlsCipher{l: "cipher1:cipher2".to_string()},
        ConfigDirective::TlsTimeout{n: "10".to_string()},
        ConfigDirective::RenegBytes{n: "10".to_string()},
        ConfigDirective::RenegPkts{n: "10".to_string()},
        ConfigDirective::RenegSec{n: "10".to_string()},
        ConfigDirective::HandWindow{n: "10".to_string()},
        ConfigDirective::TranWindow{n: "10".to_string()},
        ConfigDirective::SingleSession,
        ConfigDirective::TlsExit,
        ConfigDirective::TlsAuth{file: "somefile".to_string(), direction: None},
        ConfigDirective::TlsAuth{file: "somefile".to_string(), direction: Some("somedirection".to_string())},
        ConfigDirective::TlsCrypt{keyfile: "somekeyfile".to_string()},
        ConfigDirective::Askpass{file: None},
        ConfigDirective::Askpass{file: Some("somefile".to_string())},
        ConfigDirective::AuthNocache,
        ConfigDirective::AuthToken{token: "sometoken".to_string()},
        ConfigDirective::TlsVerify{cmd: "somecmd".to_string()},
        ConfigDirective::TlsExportCert{directory: "somedirectory".to_string()},
        ConfigDirective::X509UsernameField{fieldname: "someieldname".to_string()},
        ConfigDirective::VerifyX509Name{name: "name".to_string(), verify_x509_name_type: "type".to_string()},
        ConfigDirective::X509Track{attribute: "attribute".to_string()},
        ConfigDirective::NsCertType{client_or_server: "client".to_string()},
        ConfigDirective::RemoteCertKu{values: vec!["v1".to_string(), "v2".to_string()]},
        ConfigDirective::RemoteCertEku{oid: "oid".to_string()},
        ConfigDirective::RemoteCertTls{client_or_server: "client|server".to_string()},
        ConfigDirective::CrlVerify{crl: "crl".to_string(), dir: Some("somedir".to_string())},
        ConfigDirective::ShowCiphers,
        ConfigDirective::ShowDigests,
        ConfigDirective::ShowTls,
        ConfigDirective::ShowEngines,
        ConfigDirective::ShowCurves,
        ConfigDirective::Genkey,
        ConfigDirective::Secret{file: "file".to_string(), direction: None},
        ConfigDirective::Mktun,
        ConfigDirective::Rmtun,
        ConfigDirective::User{user: "user".to_string()},
        ConfigDirective::Group{group: "group".to_string()},
        ConfigDirective::WinSys{path: "path".to_string()},
        ConfigDirective::IpWin32{method: "method".to_string()},
        ConfigDirective::RouteMethod{m: "m".to_string()},
        ConfigDirective::DhcpOption{dhcp_option_type: "type".to_string(), parm: None},
        ConfigDirective::DhcpOption{dhcp_option_type: "type".to_string(), parm: Some("parm1".to_string())},
        ConfigDirective::TapSleep{n: "10".to_string()},
        ConfigDirective::ShowNetUp,
        ConfigDirective::BlockOutsideDns,
        ConfigDirective::DhcpRenew,
        ConfigDirective::DhcpRelease,
        ConfigDirective::RegisterDns,
        ConfigDirective::PauseExit,
        ConfigDirective::Service{exit_event: "some_exit_event".to_string(), initial_state_of_event: None},
        ConfigDirective::Service{exit_event: "some_exit_event".to_string(), initial_state_of_event: Some("0".to_string())},
        ConfigDirective::ShowAdapters,
        ConfigDirective::AllowNonadmin{tap_adapter: None},
        ConfigDirective::AllowNonadmin{tap_adapter: Some("someadapter".to_string())},
        ConfigDirective::ShowValidSubnets,
        ConfigDirective::ShowNet,
        ConfigDirective::ShowPkcs11Ids{provider: Some("someprovider".to_string()), cert_private: None},
        ConfigDirective::ShowPkcs11Ids{provider: Some("someprovider".to_string()), cert_private: Some("somecertprovider".to_string())},
        ConfigDirective::ShowGateway{v6target: None},
        ConfigDirective::ShowGateway{v6target: Some("somev6target".to_string())},
        ConfigDirective::IfconfigIpv6{ipv6addr: "someipv6addr".to_string(), ipv6remote: "someipv6remote".to_string()},
        ConfigDirective::RouteIpv6{ipv6addr: "someipv6addr".to_string(), gateway: None, metric: None},
        ConfigDirective::RouteIpv6{ipv6addr: "someipv6addr".to_string(), gateway: Some("somegateway".to_string()), metric: None},
        ConfigDirective::RouteIpv6{ipv6addr: "someipv6addr".to_string(), gateway: Some("somegateway".to_string()), metric: Some("somemetric".to_string())},
        ConfigDirective::ServerIpv6{ipv6addr: "someipv6addr".to_string()},
        ConfigDirective::IfconfigIpv6Pool{ipv6addr: "someipv6addr".to_string()},
        ConfigDirective::IfconfigIpv6Push{ipv6addr: "someipv6addr".to_string(), ipv6remote: "someipv6remote".to_string()},
        ConfigDirective::IrouteIpv6{ipv6addr: "someipv6addr".to_string()},
        ConfigDirective::KeyDirection{direction: "1".to_string()},
        ConfigDirective::ServerGateway(ServerGatewayArg::GatewayConfig{
            gateway: "somegateway".to_string(),
            netmask: "somenetmask".to_string(),
            pool_start_ip: "some_start_ip".to_string(),
            pool_end_ip: "some_end_ip".to_string(),
        }),
        ConfigDirective::ServerGateway(ServerGatewayArg::NoGateway),
        ];
    let test_ovpnfile = include_str!("test.ovpn");
    let test_reader = BufReader::new(test_ovpnfile.as_bytes());
    let result_wrapped = ovpnfile::parse(test_reader);
    spectral::assert_that(&result_wrapped.is_ok()).is_true();
    let result = result_wrapped.unwrap();
    spectral::assert_that(&result.directives.len()).is_equal_to(&expected_result.len());
    for (index, expected_item) in expected_result.iter().enumerate() {
        let actual_result = result.directives[index].result.clone();
        spectral::asserting(&format!("Config index {}", index)).that(&actual_result).is_equal_to(expected_item);
    }
}

#[test]
fn test_reads_file_with_comments() {
    let test_ovpnfile = include_str!("test_with_comments.ovpn");
    let test_reader = BufReader::new(test_ovpnfile.as_bytes());
    let result_wrapped = ovpnfile::parse(test_reader);
    assert!(result_wrapped.is_ok());
    let result = result_wrapped.unwrap();
    spectral::assert_that(&result.warnings.len()).is_equal_to(0);
    let directives: Vec<ConfigDirective> = result.directives.iter().map(|d| d.result.clone()).collect();
    spectral::assert_that(&directives).is_equal_to(
        vec![
        ConfigDirective::Help,
        ConfigDirective::Remote{host: "somehost".to_string(), port: Some("someport".to_string()), proto: None},
        ]
        )
}
